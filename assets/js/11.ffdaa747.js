(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{417:function(t,a,s){"use strict";s.r(a);var r=s(35),o=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"java-script"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-script"}},[t._v("#")]),t._v(" Java Script")]),t._v(" "),s("h2",{attrs:{id:"谈谈你对原型链的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对原型链的理解"}},[t._v("#")]),t._v(" 谈谈你对原型链的理解？")]),t._v(" "),s("p",[s("strong",[t._v("原型对象")]),t._v("：绝⼤部分的函数(少数内置函数除外)都有⼀个 prototype 属性,这个属性指针指向原型对象，这个对象就是通过调用构造函数创建的对象(实例)的"),s("strong",[t._v("原型")]),t._v(",⽽所有被创建的 对象都会共享原型对象,因此这些对象便可以访问原型对象的属性。")]),t._v(" "),s("p",[s("strong",[t._v("原型链")]),t._v("：原因是每个对象都有 "),s("strong",[t._v("proto")]),t._v(" 属性，此属性指向该对象的构造函数的原型。对象可以通过 "),s("strong",[t._v("proto")]),t._v(" 与上游的构造函数（"),s("strong",[t._v("constructor")]),t._v("）的原型对象（"),s("strong",[t._v("prototype")]),t._v("）连接起来，⽽上游的原型对象也有⼀个 "),s("strong",[t._v("proto")]),t._v(" ，这样就形成 了原型链。")]),t._v(" "),s("p",[s("strong",[t._v("判断构造函数与实例关系")]),t._v(" instanceof操作符和isPrototypeOf()方法")]),t._v(" "),s("ul",[s("li",[t._v("instanceof操作符左侧是一个普通对象，右侧是一个函数。eg: o instanceof Foo，instanceof关键字做的事情是：判断o的原型链上是否有Foo.prototype指向的对象。")]),t._v(" "),s("li",[t._v("isPrototypeOf()不关心构造函数，它只需要一个可以用来判断的对象就行。以Foo.prototype.isPrototypeOf(o)为例，isPrototypeOf()做的事情是：判断在a的原型链中是否出现过Foo.prototype")])]),t._v(" "),s("p",[s("strong",[t._v("new过程")]),t._v("："),s("br"),t._v("\n1、创建一个细新的javaScript对象（即 {} ）"),s("br"),t._v("\n2、为步骤1新创建的对象添加属性proto ，将该属性链接至构造函数的原型对象"),s("br"),t._v("\n3、将this指向这个新对象"),s("br"),t._v("\n4、执行构造函数内部的代码（例如给新对象添加属性）"),s("br"),t._v("\n5、如果构造函数返回非空对象，则返回该对象，否则返回刚创建的新对象。")]),t._v(" "),s("h2",{attrs:{id:"谈谈你对闭包的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对闭包的理解"}},[t._v("#")]),t._v(" 谈谈你对闭包的理解？")]),t._v(" "),s("p",[s("strong",[t._v("MDN 的解释")]),t._v("：闭包是函数和声明该函数的词法环境的组合。\n"),s("strong",[t._v("个人理解")]),t._v("：闭包 =『函数』和『函数体内可访问的变量总和』")]),t._v(" "),s("h2",{attrs:{id:"前端有几种储存的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端有几种储存的方式"}},[t._v("#")]),t._v(" 前端有⼏种储存的⽅式？")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("cookies： 在 HTML5 标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带 cookie ⽅便，缺点是⼤⼩只有 4k， ⾃动请求头加⼊ cookie 浪费流量，每个 domain 限制 20 个 cookie，使⽤起来麻烦需要⾃⾏封装")])]),t._v(" "),s("li",[s("p",[t._v("localStorage：HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删 除），⼤⼩为 5M，兼容 IE8+")])]),t._v(" "),s("li",[s("p",[t._v("sessionStorage：与 localStorage 基本类似，区别是 sessionStorage 当⻚⾯关闭后会被清理，⽽且与 cookie、 localStorage 不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式")])]),t._v(" "),s("li",[s("p",[t._v("Web SQL：2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实 现，web sql 类似于 SQLite，是真正意义上的关系型数据库，⽤ sql 进⾏操作，当我们⽤ JavaScript 时要进⾏转换， 较为繁琐。")])]),t._v(" "),s("li",[s("p",[t._v("IndexedDB： 是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 NoSQL 数据库，⽤键值对进⾏储存，可以进⾏快 速读取操作，⾮常适合 web 场景，同时⽤ JavaScript 进⾏操作会⾮常⽅便。")])])]),t._v(" "),s("h2",{attrs:{id:"类型转换的规则有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型转换的规则有哪些"}},[t._v("#")]),t._v(" 类型转换的规则有哪些？")]),t._v(" "),s("p",[s("strong",[t._v("原理")]),t._v("：类型转换指的是将⼀种类型转换为另⼀种类型，例如:")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//string")]),t._v("\n")])])]),s("p",[t._v("类型转换分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循⼀定的原理,遵循 ECMA-262 中提到的转换规则。"),s("br"),t._v("\n这是 JavaScript 种类型转换可以从原始类型转为引⽤类型,同样可以将引⽤类型转为原始类型,转为原始类型的抽象操作 为 ToPrimitive ,⽽后续更加细分的操作为: ToNumber ToString ToBoolean 。"),s("br"),t._v("\nTODO：\n"),s("img",{attrs:{src:"/1.jpeg",alt:"An image"}})]),t._v(" "),s("h2",{attrs:{id:"讲讲-javascript-垃圾回收-内存管理-是怎么做的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#讲讲-javascript-垃圾回收-内存管理-是怎么做的"}},[t._v("#")]),t._v(" 讲讲 JavaScript 垃圾回收(内存管理)是怎么做的？")]),t._v(" "),s("p",[t._v("todo:\n1222")])])}),[],!1,null,null,null);a.default=o.exports}}]);